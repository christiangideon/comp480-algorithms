# File: pa4.py
# Authors: Samuel Cacnio and Christian Gideon
# Date: 5/12/23
# Description: Sudoku solver using backtracking methodology

import copy
from pa4helper import Node
from pa4helper import Cell

def preprocess(size, filename):
    """
    Preprocesses the Sudoku problem input

    Parameters:
        size (int): the length/width of the sudoku puzzle
        filename (file): the file containing the sudoku setup
    
    Returns:
        grid (2D array): the formatted grid of subgrids
    """

    #Determine the number of options and assign what those options are
    if size == 9: # size is 9 x 9 grid
        options = ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
    elif size == 16: # size is 16 x 16 grid
        options = ["1", "2", "3", "4", "5", "6", "7", "8", "9",
                   "A", "B", "C", "D", "E", "F", "G"]
    else: # size is 25 x 25 grid
        options = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
                   "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
                   "U", "V", "W", "X", "Y"]

    #Setting up empty 2D grid
    grid = [[Cell(j, i, None, list(options)) for i in range(size)] for j in range(size)]
    root = Node(size, grid, 0)

    #Placing cells with values into the grid
    f = open(filename)
    for line in f:
        line = line.split()
        x = int(line[0])-1
        y = int(line[1])-1
        val = line[2]
        if root.filled < root.size**2:
            root.set_cell(x, y, val)

    solved = False #track if preprocessing completed game
    if root.filled == size * size:
        solved = True
    
    return root, solved

def find_empty(grid):
    """
    Returns sorted list of Cells in grid that have None as their values
    """
    empty_cells = []
    for row in range(0, grid.size):
        for col in range(0, grid.size):
            cell = grid.cells[row][col]
            if cell.value == None:
                empty_cells.append(cell)
    sorted(empty_cells) #by ascending number of options to find cutoffs faster
    return empty_cells


def solve_recur(grid, empty_list, nodes):
    """
    Recursively solves the Sudoku problem by producing Nodes (grids) which
    "guess" for each row.
    
    Parameters:
    grid (Node) - game of Sudoku to solve
    empty_list (list[Cells]) - list of empty cells in grid that have to be filled
    nodes (int) - stores current number of nodes in back tracking tree
    
    Returns:
    A tuple containing a completed Sudoku game or False if Sudoku game is impossible
        AND nodes
    """

    if len(empty_list) == 0 or (grid.filled==grid.size**2): #conditions for a completed game
        return grid, nodes

    for cell in empty_list:
        if cell.value == None:
            for branch in cell.options:
                nodes += 1
                problem = copy.deepcopy(grid) #Our deep copy of the grid

                valid_elims = problem.set_cell(cell.row, cell.column, branch) #Eliminates options based on the selected branch
                if valid_elims == False: #decision leads to bad game, continue to next possible food
                    continue

                if problem.filled == problem.size**2:
                    return problem, nodes
                remainder = find_empty(problem)
                solution = solve_recur(problem, remainder, nodes) #recursive call on grid copy with newly filled cells
                if solution[0] != False:
                    return solution[0], solution[1]
                
            return False, nodes
     

def solve(size, filename):
    """
    Solves the Sudoku problem specified in input file filename.
    The size of the problem is size.  (For example, for a 9 x 9 Sudoku,
    size is 9.)
    
    Returns a tuple of size 2.  The first element is a nested list containing
    the solution to the problem (row is the first index, col the second).
    The second element of the tuple is the number of nodes in the state space
    tree that were generated by your solution.
    """

    grid, solved = preprocess(size, filename)
    total_nodes = 1 #created in the preprocessing
    remaining = find_empty(grid)

    if solved:
        # print("Solved!")
        solution = (grid, total_nodes)
    else:
        #Start guessing recursively with whichever spots have the least amount of remaining options
        solution = solve_recur(grid, remaining, total_nodes)

    #print(solution)
    if solution[0] is not False:
        #print(solution[0])
        answer = [[]]
        for row in solution[0].cells:
            answer.append([])
            for cell in row:
                answer[cell.row].append(cell.value)
        answer.remove(answer[len(answer) - 1]) #Last random empty doesn't need to be there
        return (answer, solution[1])
    else:
        return None, solution[1]
    


if __name__ == "__main__":
    SIZE = 16
    FILENAME = "p16.txt"
    #print(FILENAME)
    solution = solve(SIZE, FILENAME)
    if not solution[0]:
        print("No solution")
    else:
        print("\nFinal answer:")
        print(solution[0])
    print(f"Nodes generated = {solution[1]}")